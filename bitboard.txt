Move table
====
pawn: 47 * 3 moves
cannon_row: 90 * (8 choose 2) * 9 moves
cannon_col: 90 * (9 choose 2) * 10 moves
rook_row: 90 * (8 choose 2) moves
rook_col: 90 * (9 choose 2) moves
horse: 90 * 8 * 2^4 moves
elephant: 7 * 4 * 2^4 moves
assistant: 8 moves
king: 24 moves
king_capture_king: 9 * 3 moves
total: 73008 moves (73 KB)

Move lookup table
====
pawn: 90 entries
cannon_row: 90 * 2^9 entries
cannon_col: 90 * 2^10 entries
rook_row: 90 * 2^9 entries
rook_col: 90 * 2^10 entries
horse: 90 * 2^4 entries
elephant: 7 * 2^4 entries
assitant: 5 entries
king: 9 entries
king_capture_king: 9 * 2^10 entries
total: 287352 entries (281 KB)


Bitboard general
========
* Board must contain 10 extra bits.

Aggregate
=========
template<uint64 final_mask>
constexpr uint64 aggregate(uint64 board, uint64 relevant_mask, uint64 magic_number, int shift) {
    return (((board & relevant_bits) * magic_number) >> shift) & final_mask;
}


Column extraction
======
relavent bits: b, b+9, b+18, b+27, b+36, for 0<=b<=8
magic number: 0, 8, 16, 24, 32 (0x101010101LL)
result bits: [b+32, b+36]

// final_mask = 31LL;
// shift = col_num + 32;

x0: b,    b+8,  b+16, ..., b+32
x1: b+9,  b+17, b+25, ..., b+33


Horse move
======
relevant bits: b-9, b-1, b+1, b+9
magic number: 0, 7, 16
result bits: [b+6, b+9]
standing for: b-1, b-9, b+1, b+9

// final_mask = 15LL;
// shift = b + 6;


Elephant move
======
relevant bits: b-10, b-8, b+8, b+10
magic number: 0, 17
result bits: [b+7, b+10]
standing for: b-10, b+8, b-8, b+10

// final_mask = 15LL;
// shift = b + 7;


Board representation
======
class Board {
  Piece board_[10][9];  // To quickly find what a piece is at a position.
  BitBoard pieces_[kMaxPieceId + 1];  // To speed up IsAttacked().
};
